{"ast":null,"code":"'use strict';\n\nconst http = require('http');\n\nconst EventEmitter = require('events');\n\nconst EE_ERROR = 'Registering more than one listener to a WebSocket is not supported.';\nconst DEFAULT_PAYLOAD_LIMIT = 16777216;\nlet _upgradeReq = null;\n\nfunction noop() {}\n\nfunction abortConnection(socket, code, name) {\n  socket.end('HTTP/1.1 ' + code + ' ' + name + '\\r\\n\\r\\n');\n}\n\nfunction emitConnection(ws) {\n  this.emit('connection', ws, _upgradeReq);\n}\n\nfunction onServerMessage(message, webSocket) {\n  webSocket.internalOnMessage(message);\n}\n\nconst native = (() => {\n  try {\n    try {\n      return process.binding('uws_builtin');\n    } catch (e) {\n      return require(\"./uws_\".concat(process.platform, \"_\").concat(process.versions.modules));\n    }\n  } catch (e) {\n    const version = process.version.substring(1).split('.').map(function (n) {\n      return parseInt(n);\n    });\n    const lessThanSixFour = version[0] < 6 || version[0] === 6 && version[1] < 4;\n\n    if (process.platform === 'win32' && lessThanSixFour) {\n      throw new Error('µWebSockets requires Node.js 6.4.0 or greater on Windows.');\n    } else {\n      throw new Error('Compilation of µWebSockets has failed and there is no pre-compiled binary ' + 'available for your system. Please install a supported C++11 compiler and reinstall the module \\'uws\\'.');\n    }\n  }\n})();\n\nnative.setNoop(noop);\nconst clientGroup = native.client.group.create(0, DEFAULT_PAYLOAD_LIMIT);\nnative.client.group.onConnection(clientGroup, external => {\n  const webSocket = native.getUserData(external);\n  webSocket.external = external;\n  webSocket.internalOnOpen();\n});\nnative.client.group.onMessage(clientGroup, (message, webSocket) => {\n  webSocket.internalOnMessage(message);\n});\nnative.client.group.onDisconnection(clientGroup, (external, code, message, webSocket) => {\n  webSocket.external = null;\n  process.nextTick(() => {\n    webSocket.internalOnClose(code, message);\n  });\n  native.clearUserData(external);\n});\nnative.client.group.onPing(clientGroup, (message, webSocket) => {\n  webSocket.onping(message);\n});\nnative.client.group.onPong(clientGroup, (message, webSocket) => {\n  webSocket.onpong(message);\n});\nnative.client.group.onError(clientGroup, webSocket => {\n  process.nextTick(() => {\n    webSocket.internalOnError({\n      message: 'uWs client connection error',\n      stack: 'uWs client connection error'\n    });\n  });\n});\n\nclass WebSocket {\n  constructor(external) {\n    this.external = external;\n    this.internalOnMessage = noop;\n    this.internalOnClose = noop;\n    this.onping = noop;\n    this.onpong = noop;\n  }\n\n  get upgradeReq() {\n    return _upgradeReq;\n  }\n\n  set onmessage(f) {\n    if (f) {\n      this.internalOnMessage = message => {\n        f({\n          data: message\n        });\n      };\n    } else {\n      this.internalOnMessage = noop;\n    }\n  }\n\n  set onopen(f) {\n    if (f) {\n      this.internalOnOpen = f;\n    } else {\n      this.internalOnOpen = noop;\n    }\n  }\n\n  set onclose(f) {\n    if (f) {\n      this.internalOnClose = (code, message) => {\n        f({\n          code: code,\n          reason: message\n        });\n      };\n    } else {\n      this.internalOnClose = noop;\n    }\n  }\n\n  set onerror(f) {\n    if (f && this instanceof WebSocketClient) {\n      this.internalOnError = f;\n    } else {\n      this.internalOnError = noop;\n    }\n  }\n\n  emit(eventName, arg1, arg2) {\n    if (eventName === 'message') {\n      this.internalOnMessage(arg1);\n    } else if (eventName === 'close') {\n      this.internalOnClose(arg1, arg2);\n    } else if (eventName === 'ping') {\n      this.onping(arg1);\n    } else if (eventName === 'pong') {\n      this.onpong(arg1);\n    }\n\n    return this;\n  }\n\n  on(eventName, f) {\n    if (eventName === 'message') {\n      if (this.internalOnMessage !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.internalOnMessage = f;\n    } else if (eventName === 'close') {\n      if (this.internalOnClose !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.internalOnClose = f;\n    } else if (eventName === 'ping') {\n      if (this.onping !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.onping = f;\n    } else if (eventName === 'pong') {\n      if (this.onpong !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.onpong = f;\n    } else if (eventName === 'open') {\n      if (this.internalOnOpen !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.internalOnOpen = f;\n    } else if (eventName === 'error' && this instanceof WebSocketClient) {\n      if (this.internalOnError !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.internalOnError = f;\n    }\n\n    return this;\n  }\n\n  once(eventName, f) {\n    if (eventName === 'message') {\n      if (this.internalOnMessage !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.internalOnMessage = message => {\n        this.internalOnMessage = noop;\n        f(message);\n      };\n    } else if (eventName === 'open') {\n      if (this.internalOnOpen !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.internalOnOpen = () => {\n        this.internalOnOpen = noop;\n        f();\n      };\n    } else if (eventName === 'close') {\n      if (this.internalOnClose !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.internalOnClose = (code, message) => {\n        this.internalOnClose = noop;\n        f(code, message);\n      };\n    } else if (eventName === 'ping') {\n      if (this.onping !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.onping = () => {\n        this.onping = noop;\n        f();\n      };\n    } else if (eventName === 'pong') {\n      if (this.onpong !== noop) {\n        throw Error(EE_ERROR);\n      }\n\n      this.onpong = () => {\n        this.onpong = noop;\n        f();\n      };\n    }\n\n    return this;\n  }\n\n  removeAllListeners(eventName) {\n    if (!eventName || eventName === 'message') {\n      this.internalOnMessage = noop;\n    }\n\n    if (!eventName || eventName === 'open') {\n      this.internalOnOpen = noop;\n    }\n\n    if (!eventName || eventName === 'close') {\n      this.internalOnClose = noop;\n    }\n\n    if (!eventName || eventName === 'ping') {\n      this.onping = noop;\n    }\n\n    if (!eventName || eventName === 'pong') {\n      this.onpong = noop;\n    }\n\n    return this;\n  }\n\n  removeListener(eventName, cb) {\n    if (eventName === 'message' && this.internalOnMessage === cb) {\n      this.internalOnMessage = noop;\n    } else if (eventName === 'open' && this.internalOnOpen === cb) {\n      this.internalOnOpen = noop;\n    } else if (eventName === 'close' && this.internalOnClose === cb) {\n      this.internalOnClose = noop;\n    } else if (eventName === 'ping' && this.onping === cb) {\n      this.onping = noop;\n    } else if (eventName === 'pong' && this.onpong === cb) {\n      this.onpong = noop;\n    }\n\n    return this;\n  }\n\n  get OPEN() {\n    return WebSocketClient.OPEN;\n  }\n\n  get CLOSED() {\n    return WebSocketClient.CLOSED;\n  }\n\n  get readyState() {\n    return this.external ? WebSocketClient.OPEN : WebSocketClient.CLOSED;\n  }\n\n  get _socket() {\n    const address = this.external ? native.getAddress(this.external) : new Array(3);\n    return {\n      remotePort: address[0],\n      remoteAddress: address[1],\n      remoteFamily: address[2]\n    };\n  } // from here down, functions are not common between client and server\n\n\n  ping(message, options, dontFailWhenClosed) {\n    if (this.external) {\n      native.server.send(this.external, message, WebSocketClient.OPCODE_PING, false);\n    }\n  }\n\n  terminate() {\n    if (this.external) {\n      native.server.terminate(this.external);\n      this.external = null;\n    }\n  }\n\n  send(message, options, cb, compress) {\n    if (this.external) {\n      if (typeof options === 'function') {\n        cb = options;\n        options = null;\n      }\n\n      const binary = options && typeof options.binary === 'boolean' ? options.binary : typeof message !== 'string';\n      native.server.send(this.external, message, binary ? WebSocketClient.OPCODE_BINARY : WebSocketClient.OPCODE_TEXT, cb ? () => {\n        process.nextTick(cb);\n      } : undefined, compress);\n    } else if (cb) {\n      cb(new Error('not opened'));\n    }\n  }\n\n  close(code, data) {\n    if (this.external) {\n      native.server.close(this.external, code, data);\n      this.external = null;\n    }\n  }\n\n}\n\nclass WebSocketClient extends WebSocket {\n  constructor(uri) {\n    super(null);\n    this.internalOnOpen = noop;\n    this.internalOnError = noop;\n    native.connect(clientGroup, uri, this);\n  }\n\n  ping(message, options, dontFailWhenClosed) {\n    if (this.external) {\n      native.client.send(this.external, message, WebSocketClient.OPCODE_PING, false);\n    }\n  }\n\n  terminate() {\n    if (this.external) {\n      native.client.terminate(this.external);\n      this.external = null;\n    }\n  }\n\n  send(message, options, cb, compress) {\n    if (this.external) {\n      if (typeof options === 'function') {\n        cb = options;\n        options = null;\n      }\n\n      const binary = options && typeof options.binary === 'boolean' ? options.binary : typeof message !== 'string';\n      native.client.send(this.external, message, binary ? WebSocketClient.OPCODE_BINARY : WebSocketClient.OPCODE_TEXT, cb ? () => {\n        process.nextTick(cb);\n      } : undefined, compress);\n    } else if (cb) {\n      cb(new Error('not opened'));\n    }\n  }\n\n  close(code, data) {\n    if (this.external) {\n      native.client.close(this.external, code, data);\n      this.external = null;\n    }\n  }\n\n}\n\nclass Server extends EventEmitter {\n  constructor(options, callback) {\n    super();\n\n    if (!options) {\n      throw new TypeError('missing options');\n    }\n\n    if (options.port === undefined && !options.server && !options.noServer) {\n      throw new TypeError('invalid options');\n    }\n\n    var nativeOptions = 0;\n\n    if (options.perMessageDeflate !== undefined && options.perMessageDeflate !== false) {\n      nativeOptions |= WebSocketClient.PERMESSAGE_DEFLATE;\n\n      if (options.perMessageDeflate.serverNoContextTakeover === false) {\n        nativeOptions |= WebSocketClient.SLIDING_DEFLATE_WINDOW;\n      }\n    }\n\n    this.serverGroup = native.server.group.create(nativeOptions, options.maxPayload === undefined ? DEFAULT_PAYLOAD_LIMIT : options.maxPayload); // can these be made private?\n\n    this._upgradeCallback = noop;\n    this._upgradeListener = null;\n    this._noDelay = options.noDelay === undefined ? true : options.noDelay;\n    this._lastUpgradeListener = true;\n    this._passedHttpServer = options.server;\n\n    if (!options.noServer) {\n      this.httpServer = options.server ? options.server : http.createServer((request, response) => {\n        // todo: default HTTP response\n        response.end();\n      });\n\n      if (options.path && (!options.path.length || options.path[0] !== '/')) {\n        options.path = '/' + options.path;\n      }\n\n      this.httpServer.on('upgrade', this._upgradeListener = (request, socket, head) => {\n        if (!options.path || options.path == request.url.split('?')[0].split('#')[0]) {\n          if (options.verifyClient) {\n            const info = {\n              origin: request.headers.origin,\n              secure: request.connection.authorized !== undefined || request.connection.encrypted !== undefined,\n              req: request\n            };\n\n            if (options.verifyClient.length === 2) {\n              options.verifyClient(info, (result, code, name) => {\n                if (result) {\n                  this.handleUpgrade(request, socket, head, emitConnection);\n                } else {\n                  abortConnection(socket, code, name);\n                }\n              });\n            } else {\n              if (options.verifyClient(info)) {\n                this.handleUpgrade(request, socket, head, emitConnection);\n              } else {\n                abortConnection(socket, 400, 'Client verification failed');\n              }\n            }\n          } else {\n            this.handleUpgrade(request, socket, head, emitConnection);\n          }\n        } else {\n          if (this._lastUpgradeListener) {\n            abortConnection(socket, 400, 'URL not supported');\n          }\n        }\n      });\n      this.httpServer.on('newListener', (eventName, listener) => {\n        if (eventName === 'upgrade') {\n          this._lastUpgradeListener = false;\n        }\n      });\n      this.httpServer.on('error', err => {\n        this.emit('error', err);\n      });\n    }\n\n    native.server.group.onDisconnection(this.serverGroup, (external, code, message, webSocket) => {\n      webSocket.external = null;\n      process.nextTick(() => {\n        webSocket.internalOnClose(code, message);\n      });\n      native.clearUserData(external);\n    });\n    native.server.group.onMessage(this.serverGroup, onServerMessage);\n    native.server.group.onPing(this.serverGroup, (message, webSocket) => {\n      webSocket.onping(message);\n    });\n    native.server.group.onPong(this.serverGroup, (message, webSocket) => {\n      webSocket.onpong(message);\n    });\n    native.server.group.onConnection(this.serverGroup, external => {\n      const webSocket = new WebSocket(external);\n      native.setUserData(external, webSocket);\n\n      this._upgradeCallback(webSocket);\n\n      _upgradeReq = null;\n    });\n\n    if (options.port !== undefined) {\n      if (options.host) {\n        this.httpServer.listen(options.port, options.host, () => {\n          this.emit('listening');\n          callback && callback();\n        });\n      } else {\n        this.httpServer.listen(options.port, () => {\n          this.emit('listening');\n          callback && callback();\n        });\n      }\n    }\n  }\n\n  handleUpgrade(request, socket, upgradeHead, callback) {\n    if (socket._isNative) {\n      if (this.serverGroup) {\n        _upgradeReq = request;\n        this._upgradeCallback = callback ? callback : noop;\n        native.upgrade(this.serverGroup, socket.external, secKey, request.headers['sec-websocket-extensions'], request.headers['sec-websocket-protocol']);\n      }\n    } else {\n      const secKey = request.headers['sec-websocket-key'];\n      const socketHandle = socket.ssl ? socket._parent._handle : socket._handle;\n      const sslState = socket.ssl ? socket.ssl._external : null;\n\n      if (socketHandle && secKey && secKey.length == 24) {\n        socket.setNoDelay(this._noDelay);\n        const ticket = native.transfer(socketHandle.fd === -1 ? socketHandle : socketHandle.fd, sslState);\n        socket.on('close', error => {\n          if (this.serverGroup) {\n            _upgradeReq = request;\n            this._upgradeCallback = callback ? callback : noop;\n            native.upgrade(this.serverGroup, ticket, secKey, request.headers['sec-websocket-extensions'], request.headers['sec-websocket-protocol']);\n          }\n        });\n      }\n\n      socket.destroy();\n    }\n  }\n\n  broadcast(message, options) {\n    if (this.serverGroup) {\n      native.server.group.broadcast(this.serverGroup, message, options && options.binary || false);\n    }\n  }\n\n  startAutoPing(interval, userMessage) {\n    if (this.serverGroup) {\n      native.server.group.startAutoPing(this.serverGroup, interval, userMessage);\n    }\n  }\n\n  close(cb) {\n    if (this._upgradeListener && this.httpServer) {\n      this.httpServer.removeListener('upgrade', this._upgradeListener);\n\n      if (!this._passedHttpServer) {\n        this.httpServer.close();\n      }\n    }\n\n    if (this.serverGroup) {\n      native.server.group.close(this.serverGroup);\n      this.serverGroup = null;\n    }\n\n    if (typeof cb === 'function') {\n      // compatibility hack, 15 seconds timeout\n      setTimeout(cb, 20000);\n    }\n  }\n\n  get clients() {\n    if (this.serverGroup) {\n      return {\n        length: native.server.group.getSize(this.serverGroup),\n        forEach: cb => {\n          native.server.group.forEach(this.serverGroup, cb);\n        }\n      };\n    }\n  }\n\n}\n\nWebSocketClient.PERMESSAGE_DEFLATE = 1;\nWebSocketClient.SLIDING_DEFLATE_WINDOW = 16; //WebSocketClient.SERVER_NO_CONTEXT_TAKEOVER = 2;\n//WebSocketClient.CLIENT_NO_CONTEXT_TAKEOVER = 4;\n\nWebSocketClient.OPCODE_TEXT = 1;\nWebSocketClient.OPCODE_BINARY = 2;\nWebSocketClient.OPCODE_PING = 9;\nWebSocketClient.OPEN = 1;\nWebSocketClient.CLOSED = 0;\nWebSocketClient.Server = Server;\nWebSocketClient.http = native.httpServer;\nWebSocketClient.native = native;\nmodule.exports = WebSocketClient;","map":null,"metadata":{},"sourceType":"script"}